# Руководство по интеграции M2M (Machine-to-Machine)

В этом документе описывается, как внешние системы могут взаимодействовать с API AgentBounty для создания и управления задачами от имени существующих пользователей.

## Обзор

Основная идея M2M-взаимодействия заключается в том, чтобы позволить автоматизированным системам (например, ботам, скриптам, другим бэкендам) запускать AI-агентов. При этом все задачи надежно привязываются к реальному пользователю, а оплата за платные результаты производится самим пользователем в безопасной браузерной среде.

Процесс разделен на две части:
1.  **Машинная часть:** M2M-клиент создает и запускает задачу, а затем запрашивает результат.
2.  **Человеческая часть:** Если результат платный, пользователь получает email-уведомление и завершает оплату в веб-интерфейсе.

## Предварительные требования

Для взаимодействия с M2M API вам понадобятся две вещи:

1.  **Сервисный токен (`MCP_SERVICE_TOKEN`):**
    *   **Что это:** Общий секретный ключ, который разрешает M2M-системам доступ к специальным эндпоинтам.
    *   **Где его взять:** Этот токен находится в файле `.env` основного приложения. Администратор должен безопасно передать его разработчику M2M-клиента.

2.  **ID пользователя (`user_id`):**
    *   **Что это:** Уникальный идентификатор пользователя из системы Auth0, от имени которого будет выполняться задача.
    *   **Почему он нужен:** Система должна знать, кто является "владельцем" задачи, чтобы проверить его существование и отправить ему на почту ссылку для оплаты.
    *   **Где его взять:** После входа в веб-интерфейс AgentBounty, `user_id` отображается в шапке сайта под именем пользователя. Его можно скопировать.

    *[SCREENSHOT: Скриншот шапки сайта с подсвеченным user_id и иконкой копирования.]*

---

## Пошаговый процесс M2M-взаимодействия

### Шаг 1: Создание задачи

M2M-клиент отправляет POST-запрос на специальный эндпоинт для создания задачи.

*   **Эндпоинт:** `POST /api/tasks/m2m/create`
*   **Заголовки:**
    *   `Authorization: Bearer <ваш_MCP_SERVICE_TOKEN>`
    *   `X-User-ID: <user_id_пользователя>`
    *   `Content-Type: application/json`
*   **Тело запроса (JSON):**
    ```json
    {
        "agent_type": "factcheck",
        "input_data": {
            "text": "Does vitamin C cure the common cold?"
        }
    }
    ```
*   **Пример `curl` запроса:**
    ```bash
    curl -X POST -H "Content-Type: application/json" \
    -H "Authorization: Bearer f44ac472df45f1692256ab189d3108673c7f3dbf37cc1f3cab58cb37ea0f5c8d" \
    -H "X-User-ID: google-oauth2|112852885116533594909" \
    -d '{
        "agent_type": "factcheck",
        "input_data": { "text": "Does vitamin C cure the common cold?" }
    }' \
    http://localhost:8000/api/tasks/m2m/create
    ```
*   **Успешный ответ (HTTP 201):**
    Сервер вернет JSON-объект созданной задачи. **Сохраните `id` задачи** для следующих шагов.
    ```json
    {
        "id": "fe1912d1-8412-4aaf-b0be-5d37ac4ea2a3",
        "user_id": "google-oauth2|112852885116533594909",
        "agent_type": "factcheck",
        "status": "pending",
        ...
    }
    ```

### Шаг 2: Запуск задачи

Сразу после создания задача находится в статусе `pending`. Чтобы запустить ее выполнение, нужно отправить POST-запрос на эндпоинт запуска.

*   **Эндпоинт:** `POST /api/tasks/{task_id}/start`
*   **Заголовки:**
    *   `Authorization: Bearer <ваш_MCP_SERVICE_TOKEN>`
    *   `X-User-ID: <user_id_пользователя>`
*   **Пример `curl` запроса:**
    ```bash
    curl -X POST \
    -H "Authorization: Bearer f44ac472df45f1692256ab189d3108673c7f3dbf37cc1f3cab58cb37ea0f5c8d" \
    -H "X-User-ID: google-oauth2|112852885116533594909" \
    http://localhost:8000/api/tasks/fe1912d1-8412-4aaf-b0be-5d37ac4ea2a3/start
    ```
Задача начнет выполняться в фоновом режиме.

### Шаг 3: Проверка статуса (Поллинг)

M2M-клиент должен периодически опрашивать статус задачи, чтобы узнать, когда она будет завершена.

*   **Эндпоинт:** `GET /api/tasks/{task_id}`
*   **Заголовки:**
    *   `Authorization: Bearer <ваш_MCP_SERVICE_TOKEN>`
    *   `X-User-ID: <user_id_пользователя>`
*   **Ответ (когда задача завершена):**
    Поле `status` изменится на `completed`.
    ```json
    {
        "id": "fe1912d1-8412-4aaf-b0be-5d37ac4ea2a3",
        "status": "completed",
        "actual_cost": 0.001,
        ...
    }
    ```

### Шаг 4: Запрос результата и передача управления пользователю

Когда задача завершена, M2M-клиент запрашивает результат.

*   **Эндпоинт:** `GET /api/tasks/{task_id}/result`
*   **Заголовки:**
    *   `Authorization: Bearer <ваш_MCP_SERVICE_TOKEN>`
    *   `X-User-ID: <user_id_пользователя>`

**Возможные ответы:**
1.  **Если результат бесплатный (`actual_cost: 0`):** Сервер сразу вернет результат.
2.  **Если результат платный:** Сервер вернет следующий JSON. Это означает, что M2M-клиент свою работу на данном этапе выполнил, и теперь очередь за пользователем.
    ```json
    {
        "status": "payment_link_sent",
        "message": "A link to complete the payment has been sent to the user's email.",
        "task_id": "fe1912d1-8412-4aaf-b0be-5d37ac4ea2a3",
        "amount": 0.001
    }
    ```
В этот момент пользователю на почту отправляется "волшебная ссылка".

*[SCREENSHOT: Скриншот письма, которое получает пользователь.]*

### Шаг 5: Оплата пользователем

1.  Пользователь открывает письмо и нажимает на ссылку вида `http://localhost:8000/?pay_task_id=...`.
2.  В браузере открывается сайт, страница прокручивается до нужной задачи, и появляется модальное окно для подтверждения платежа.
3.  Пользователь подтверждает транзакцию в своем крипто-кошельке (например, MetaMask).

*[SCREENSHOT: Скриншот модального окна оплаты в браузере.]*

### Шаг 6: Получение оплаченного результата

После того как пользователь оплатил задачу, M2M-клиент (или любой другой клиент) может снова запросить результат и на этот раз получить его.

*   **Эндпоинт:** `GET /api/tasks/{task_id}/result` (тот же, что и в шаге 4)
*   **Заголовки:** Те же.
*   **Успешный ответ (HTTP 200):**
    Сервер вернет полный результат задачи.
    ```json
    {
        "task_id": "fe1912d1-8412-4aaf-b0be-5d37ac4ea2a3",
        "status": "completed",
        "result_type": "text",
        "content": "## Post Summary...",
        ...
    }
    ```

---

## Роль Auth0 в процессе M2M

Auth0 играет ключевую, но не всегда очевидную роль в обеспечении безопасности и связности этого процесса:

1.  **Проверка существования пользователя:** Когда M2M-клиент отправляет запрос с `X-User-ID`, наше приложение не просто слепо доверяет этому ID. Оно немедленно отправляет запрос к Auth0 Management API и спрашивает: "Существует ли пользователь с таким ID?". Если Auth0 отвечает "нет", наш сервер отклоняет M2M-запрос с ошибкой `404 Not Found`. Это предотвращает создание "задач-сирот" от имени вымышленных пользователей.

2.  **Получение Email для уведомления:** После успешной проверки пользователя, когда приходит время отправить ссылку для оплаты, наше приложение снова обращается к Auth0 и запрашивает профиль пользователя по его `user_id`. Из этого профиля мы берем `email`, на который и отправляем уведомление.

Таким образом, Auth0 выступает как **единый источник правды** о пользователях, позволяя M2M-системе безопасно инициировать действия, которые в конечном итоге требуют участия реального, верифицированного человека.
